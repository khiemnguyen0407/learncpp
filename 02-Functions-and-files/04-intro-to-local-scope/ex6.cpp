/* Introduction to temporary objects */

/*
A temporary object (also sometimes called an anonymous object) is an unnamed object that is used to 
hold a value that is only needed for a short period of time. Temporary objects are generated by the 
compiler when they are needed.
*/

// There are many different ways that temporary values can be created, but here's a common one:
#include <iostream>

int get_value_from_user()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << get_value_from_user() << '\n'; // where does the returned value get stored?

	return 0;
}

// In the above program, the function get_value_from_user() returns the value stored in local 
// variable input back to the caller. Because input will be destroyed at the end of the function, 
// the caller receives a copy of the value so that it has a value it can use even after input is 
// destroyed.

// But where is the value that is copied back to the caller stored? We have not defined any 
// variables in main(). The answer is that the return value is stored in a temporary object. This 
// temporary object is then passed to std::cout to be printed.

/* 
Key insight:
Return by value returns a temporary object (that holds a copy of the return value) to the caller.

Temporary objects have no scope at all (this makes sense, since scope is a property of an 
identifier, and temporary objects have no identifier).

Temporary objects are destroyed at the end of the full expression in which they are created. This 
means temporary objects are always destroyed before the next statement executes. In our example 
above, the temporary object created to hold the return value of get_value_from_user() is destroyed 
after std::cout << get_value_from_user() << '\n' executes.

In the case where a temporary object is used to initialize a variable, the initialization happens 
before the destruction of the temporary. In modern C++ (especially since C++17), the compiler has 
many tricks to avoid generating temporaries where previously it would have needed to. For example, 
when we use a return value to initialize a variable, this would normally result in the creation of 
a temporary holding the return value, and then using the temporary to initialize the variable. 
However, in modern C++, the compiler will often skip creating the temporary and just initialize the 
variable directly with the return value. Similarly, in the above example, since the return value of 
get_value_by_user() is immediately output, the compiler can skip creation and destruction of the 
temporary in main(), and use the return value of get_value_by_user() to directly initialize the 
parameter of operator<<.
*/